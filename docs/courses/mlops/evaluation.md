---
template: lesson.html
title: Evaluating ML Models
description: Evaluating ML models by assessing overall, per-class and slice performances.
keywords: evaluation, mlops, applied ml, machine learning, ml in production, machine learning in production, applied machine learning
image: https://madewithml.com/static/images/mlops.png
repository: https://github.com/GokuMohandas/MLOps
notebook: https://colab.research.google.com/github/GokuMohandas/MLOps/blob/main/notebooks/tagifai.ipynb
---

{% include "styles/lesson.md" %}

## Intuition

Evaluation is an integral part of modeling and it's one that's often glossed over. We'll often find evaluation to involve simply computing the accuracy or other global metrics but for many real work applications, a much more nuanced evaluation process is required. However, before evaluating our model, we always want to:

- be clear about what metrics we are prioritizing
- be careful not to over optimize on any one metric because it may mean you're compromising something else

```python linenums="1"
# Metrics
metrics = {"overall": {}, "class": {}}
```
```python linenums="1"
# Data to evaluate
device = torch.device("cuda")
loss_fn = nn.BCEWithLogitsLoss(weight=class_weights_tensor)
trainer = Trainer(model=model.to(device), device=device, loss_fn=loss_fn)
test_loss, y_true, y_prob = trainer.eval_step(dataloader=test_dataloader)
y_pred = np.array([np.where(prob >= threshold, 1, 0) for prob in y_prob])
```

## Coarse-grained

While we were iteratively developing our baselines, our evaluation process involved computing the coarse-grained metrics such as overall precision, recall and f1 metrics.

```python linenums="1"
# Overall metrics
overall_metrics = precision_recall_fscore_support(y_test, y_pred, average="weighted")
metrics["overall"]["precision"] = overall_metrics[0]
metrics["overall"]["recall"] = overall_metrics[1]
metrics["overall"]["f1"] = overall_metrics[2]
metrics["overall"]["num_samples"] = np.float64(len(y_true))
print (json.dumps(metrics["overall"], indent=4))
```
<pre class="output">
{
    "precision": 0.7896647806486397,
    "recall": 0.5965665236051502,
    "f1": 0.6612830799421741,
    "num_samples": 218.0
}
</pre>

!!! note
    The [precision_recall_fscore_support()](https://scikit-learn.org/stable/modules/generated/sklearn.metrics.precision_recall_fscore_support.html){:target="_blank"} function from scikit-learn has an input parameter called `average` which has the following options below. We'll be using the different averaging methods for different metric granularities.

    - `None`: metrics are calculated for each unique class.
    - `binary`: used for binary classification tasks where the `pos_label` is specified.
    - `micro`: metrics are calculated using global TP, FP, and FN.
    - `macro`: per-class metrics which are averaged without accounting for class imbalance.
    - `weighted`: per-class metrics which are averaged by accounting for class imbalance.
    - `samples`: metrics are calculated at the per-sample level.

## Fine-grained

Inspecting these coarse-grained, overall metrics is a start but we can go deeper by evaluating the same fine-grained metrics at the categorical feature levels.

```python linenums="1"
# Per-class metrics
class_metrics = precision_recall_fscore_support(y_test, y_pred, average=None)
for i, _class in enumerate(label_encoder.classes):
    metrics["class"][_class] = {
        "precision": class_metrics[0][i],
        "recall": class_metrics[1][i],
        "f1": class_metrics[2][i],
        "num_samples": np.float64(class_metrics[3][i]),
    }
```
```python linenums="1"
# Metrics for a specific class
tag = "transformers"
print (json.dumps(metrics["class"][tag], indent=2))
```
<pre class="output">
{
  "precision": 0.6428571428571429,
  "recall": 0.6428571428571429,
  "f1": 0.6428571428571429,
  "num_samples": 28.0
}
</pre>

As a general rule, the classes with fewer samples will have lower performance so we should always work to identify the class (or fine-grained slices) of data that our model needs to see more samples of to learn from.

```python linenums="1"
# Number of training samples per class
num_samples = np.sum(y_train, axis=0).tolist()
```

```python linenums="1"
# Number of samples vs. performance (per class)
f1s = [metrics["class"][_class]["f1"]*100. for _class in label_encoder.classes]
sorted_lists = sorted(zip(*[num_samples, f1s])) # sort
num_samples, f1s = list(zip(*sorted_lists))
```

```python linenums="1"
# Plot
n = 7 # num. top classes to label
fig, ax = plt.subplots()
ax.set_xlabel("# of training samples")
ax.set_ylabel("test performance (f1)")
fig.set_size_inches(25, 5)
ax.plot(num_samples, f1s, "bo-")
for x, y, label in zip(num_samples[-n:], f1s[-n:], label_encoder.classes[-n:]):
    ax.annotate(label, xy=(x,y), xytext=(-5, 5), ha="right", textcoords="offset points")
```

<div class="ai-center-all">
  <img width="1000" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABbAAAAFCCAYAAAAgzfu6AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADh0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uMy4yLjIsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy+WH4yJAAAgAElEQVR4nOzdd3hUZdrH8e9MJpmUSe8JndBRiqCiCNI7oruii6KILjYsrK6yr4AoFsACCgvqiopl1dUFlCqIiIigrIAIoYaenkBIL5OZ94+BgZAEAySZIfw+1+UlOeU59xk4mZn73Od+DHa73Y6IiIiIiIiIiIiIiJsxujoAEREREREREREREZGKKIEtIiIiIiIiIiIiIm5JCWwRERERERERERERcUtKYIuIiIiIiIiIiIiIW1ICW0RERERERERERETckhLYIiIiIiIiIiIiIuKWlMAWEREREREREREREbdkcnUANe348TxsNrurwxBxudBQC5mZua4OQ0TOoOtSxP3ouhRxP7ouRdyLrkkR91MXrkuj0UBwsF+F6+p8AttmsyuBLXKSrgUR96PrUsT96LoUcT+6LkXci65JEfdTl69LtRAREREREREREREREbekBLaIiIiIiIiIiIiIuCUlsEVERERERERERETELSmBLSIiIiIiIiIiIiJuSQlsEREREREREREREXFLSmCLiIiIiIiIiIiIiFsy1cZBpk2bxjfffENiYiKLFy+mefPmABw4cIDx48eTlZVFUFAQ06ZNo1GjRn+4Ti4PG3aksGBtApnZRYQGmLmle1O6tIlydVgiIiIiIiIiIiJSS2qlArtXr1588sknxMbGlln+7LPPMmLECL755htGjBjBpEmTqrRO6r4NO1KYv3wXmdlFAGRmFzF/+S427EhxcWQiIiIiIiIiIiJSW2olgd2pUyeio6PLLMvMzCQ+Pp7BgwcDMHjwYOLj4zl27Ng518nlYcHaBIqttjLLiq02FqxNcFFEIiIiIiIiIiIiUttqpYVIRZKTk4mMjMTDwwMADw8PIiIiSE5Oxm63V7ouJCTkvI4TGmqp9til5h07WXld0fLwcP9ajqbu0Gsn4n50XYq4H12XIu5H16WIe9E1KeJ+6vJ16bIEdm3JzMzFZrO7Ogw5T95mEwVF1nLLQwLMpKfnuCCiS194uL9eOxE3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2pTq63IAcLpcrNuRRoemkfiZNRJHREREREREROqGSkeItG7dmkcffZTExETsdjuvvPJKhc8bOXKk14oTqSnqwJaq6tu1Eeu2p/H+4u20bhRBZKi/T+vZm5rD8Vw7SS00PkRERERERERE6o5K2/SmT59O69atOXaseKGy1NTUCj9E6gIF2FJVRqOBode2wel08fZXW3w+SmTt9jSMBgMdExVgi4iIiIiIiEjdUWkHdlRUFA8++CAulwu73c7f//53TCaFfFI3Wfw0ckGqrl5EILde3Zz3vvmdb9ce5OrOCT6rZd32NFokhBEc4OezGkREREREREREqttZUzuDwcCiRYswGAw1UY+IT6gDW85Vr6T6tG8aycff7uBIZp5PakjLyufAsVyNDxERERERERGROsejttM2bdqwe/dub9ci4jMWBdhyjgwGA/cNaIPZaGT2gi04nTU/SmTdjjQAkporwBYRERERERGRusWjALtbt24MHz6cV199lU8++YS5c+e6P6rTjBkzaNWqFdu2bQNg3bp1DBw4kL59+zJkyBDS09Or9XwiJdSBLecjIsTKnde0ZMfB43y9el+Nn3/t9jTiowKJjQys8XOLiIiIiIiIiHhTpTOwS1uzZg0NGjRg9erVZbYbDAZuueWWailk06ZNrFu3jgYNGgDgdDoZNWoUzz33HF26dGHmzJm88MILPPfcc9VyPpHSzCYDRo3JkfNwabtY1mw7xvwVu+jYLIqEesE1ct68gkK27c+iT7eGNXI+EREREREREZGa5FGA/d5773m1CLvdzrPPPsuLL77I3XffDcDGjRuxWq106dIFgNtuu43evXsrwBavMBgMWC1GCh1OX5ciFyiDwcBd/VqxfVYWsxZsZuw9XTCbvL846G+7MihyukhuHuP1c4mIiIiIiIiI1DSPAmyAzMxMli9fTlpaGsOGDePIkSO4XC7i4uLOu4hXXnmFgQMHkpCQ4N52+PBh6tev7/46MjISp9NJVlYW4eHhHh87KqpmuiDrApPJiNXqR0xMiK9L8YkAq5lCR2Gdfv11+bXVBjHAI39M5h9vr2bJ2kP8qX8br59zy/7fCQu20K1TA0xGvYvgQqTrUqT20XUpUvvouhSpXXRNitQ+dfm69CjAXr16NY888gjt27dnzZo1DBs2jL179/LWW2/xz3/+87wKWLt2LRs3buSvf/3r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TK/nyy8/5z//eZejR48SHh7BnXfezY033gycGlVy88238vHHH9C1azfq109gz57dWCwWvvtuGbGxcYwdO57WrdsCcMst1/Pkk2Pp2rU7s2e/ccbn/v77Vp5//lkOHDhAVEJbpq8pZNNlHXj8z38+4+tZtz2NVo3CCfTXP90iIiIiIiIicnFQB7ZINdu3bw/z5n3CrFnvsnjxd7z00gzi4+szd+5HrFixjBkz3mT+/IWEhITw4ouTy+3/9NPj6dOnP3fccTeLF68oF17n5+czbdoLvPjiKyxe/B2vv/4WzZu39Li+r7/+kqeeGsdnn32NyWRi2rQXADh27ChPPPFn7rlnCF99tZSHHx7J2LFPkpmZ6d73m2++YtSop1m0aDk33ngL+/btZf/+fe7HFy/+hmuu6VfunB9+OIeYmHosWPA/vvhiEfff/xAGgwGn08kTTzxG8+Yt+fTThUybNpOPP/6An35aBcBbb/2LgwcP8PHH83nxxVdZuHCBx6/zbK8nIiKSKVOmsWjRcsaMGcerr77E779vde+fkZFOdnY2c+d+wRNPPA3AypXf8Yc/9OHrr7+lR48reemlKZWev7LnFhYWMmbMX+nf/3oWLlzK3bcNIufwRtbtSMNRVHlXe2pGHofT8zQ+REREREREREQuKh4F2N26datwe0pKSrUWI1IXGI0m7HY7u3fvwuFwEB9fnwYNEvjss/8yYsSD1KsXi8ViYciQ+1m2bMk5jacwGg3s2rUTm62A6OhomjVL9Hjfvn0H0KxZcwICAhg27AGWLl1MUVER33zzFSkpl5GS0gOj0UjXrpfSunUbfvxxpXvfAQOup1mzRMxmM8HBwVxxRU/+979vANi/fx979+6hR4+e5c5pNptJT08jNfUwZrOZTp2SMRgMbNmymaysTO67bzh+fn40aJDAwIE3smTJIgCWLv0fd989hNDQMGJj47jllts8fp1nez2XXdaDBg0SMBgMJCdfQrdul7J+/Vr3/gaDgaFD78disWC1+gPQoUMSKSk9MJlM9O07gB07tld6/sqeu2nTbxQVFTF48G2YzWYG9O1Dk8RWHM+18+WqvZUeb932NAAF2CIiIiIiIiJyUfHofeiFhYUVbruYZuCKeCohoSGPPvo4b731Jrt376J790t55JG/kJp6mDFjRpVZrM9kMpGZmXHG402dOolFixYCcNdd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qMhrhYmIXMwG9UzEYi77T7TFbGRQz0QfVSQiIiIiIiIiUvM8CrBXr15Nv379+OKLL5g5cyYAe/fuZfz48d6sTUTkopXSLo57+rd2d1xHhVq5p39rzb8WERERERERkYuKRyNEJk2axLRp00hJSaFr164AdOrUiQ0bNni1OBGRi1lKuzgF1iIiIiIiIiJyUfOoA/vgwYOkpKQAYDAYAPDz89MIERERERERERERERHxGo8C7MTERFasWFFm2w8//EDLli29UpSIiIiIiIiIiIiIiEcjREaPHs39999Pr169KCgoYNy4cSxdutQ9D1tEREREREREREREpLp51IGdlJTE559/TvPmzbn55ptJSEhg7ty5dOzY0dv1iYiIiIiIiIiIiMhFyqMO7NmzZzN06FCGDx9eZvvbb7/Nfffd55XCREREREREREREROTi5lEH9muvvVbh9tdff71aixERERERERERERERKXHGDuxVq1YB4HQ6+fHHH3G5XO7HDhw4QFBQkHerExEREREREREREZGL1hkD7KeffhoAm83GmDFj3NsNBgMxMTGMHTvWu9WJiIiIiIiIiIiIyEXrjAH20qVLAXjiiSeYMmVKjRQkIiIiIiIiIiIiIgIezsBWeC0iIiIiIiIiIiIiNc2jAFtEREREREREREREpKYpwBYRERERERERERGRWkkBtoiIiIiIiIiIiIjUSmdcxLEmZGZm8sQTT7Bv3z4sFguNGzfm2WefJTIyknXr1jFu3DhsNhsNGjRg6tSpREVF+bpkEREREREREREREakBPu/ANhgMDBs2jG+++YYvvviChg0b8sILL+B0Ohk1ahTjxo3jm2++oUuXLrzwwgu+LldEREREREREREREaojPA+zw8HC6d+/u/jopKYlDhw6xceNGrFYrXbp0AeC2227j66+/9lWZIiIiIiIiIiIiIlLDfB5gl+Z0Ovnggw+4+uqrOXz4MPX/v717j6n6vv84/joHBEVFBAEP6iAwtRSWiaWabUWnMa0Y6rDWwVzplqYXY9YQl3altl6G2wqytc0MC3Nrm21latc6hlpFl4ruYq0naDtKbZSiVkEoCqOIgpzz/f3hen6leE69AOcjPB+JyfleeR9O3vn4feVzPsTEeI6Fh4fL7XartbXVjxUCAAAAAAAAAAaK39fA/rx169YpJCREDzzwgPbs2dMn94yI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
">
</div>

There are, of course, nuances to this general rule such as the complexity of distinguishing between some classes where we may not need as many samples for easier sub-tasks. In our case, classes with over 100 training samples consistently perform better than 0.6 f1 score, whereas the other class' performances are mixed.

## Confusion matrix

Besides just inspecting the metrics for each class, we can also identify the true positives, false positives and false negatives. Each of these will give us insight about our model beyond what the metrics can provide.

- **True positives (TP)**: prediction = ground-truth → learn about where our model performs well.
- **False positives (FP)**: falsely predict sample belongs to class → identify potentially mislabeled samples.
- **False negatives (FN)**: falsely predict sample does not belong to class → identify the model's less performant areas to upsample later.

> It's a good to have our FP/FN samples feed back into our annotation pipelines in the event we want to fix their labels and have those changes be reflected everywhere.

```python linenums="1"
# TP, FP, FN samples
index = label_encoder.class_to_index[tag]
tp, fp, fn = [], [], []
for i in range(len(y_test)):
    true = y_test[i][index]
    pred = y_pred[i][index]
    if true and pred:
        tp.append(i)
    elif not true and pred:
        fp.append(i)
    elif true and not pred:
        fn.append(i)
```
```python linenums="1"
print (tp)
print (fp)
print (fn)
```
<pre class="output">
[4, 9, 27, 38, 40, 52, 58, 74, 79, 88, 97, 167, 174, 181, 186, 191, 194, 195]
[45, 54, 98, 104, 109, 137, 146, 152, 162, 190]
[55, 59, 63, 70, 87, 93, 125, 144, 166, 201]
</pre>

```python linenums="1"
index = tp[0]
print (X_test_raw[index])
print (f"true: {label_encoder.decode([y_test[index]])[0]}")
print (f"pred: {label_encoder.decode([y_pred[index]])[0]}\n")
```
<pre class="output">
simple transformers transformers classification ner qa language modeling language generation t5 multi modal conversational ai
true: ['language-modeling', 'natural-language-processing', 'question-answering', 'transformers']
pred: ['attention', 'huggingface', 'language-modeling', 'natural-language-processing', 'transformers']
</pre>

```python linenums="1"
# Sorted tags
sorted_tags_by_f1 = OrderedDict(sorted(
        metrics["class"].items(), key=lambda tag: tag[1]["f1"], reverse=True))
```
```python linenums="1"
# Samples
num_samples = 3
if len(tp):
    print ("\n=== True positives ===")
    for i in tp[:num_samples]:
        print (f"  {X_test_raw[i]}")
        print (f"    true: {label_encoder.decode([y_test[i]])[0]}")
        print (f"    pred: {label_encoder.decode([y_pred[i]])[0]}\n")
if len(fp):
    print ("=== False positives === ")
    for i in fp[:num_samples]:
        print (f"  {X_test_raw[i]}")
        print (f"    true: {label_encoder.decode([y_test[i]])[0]}")
        print (f"    pred: {label_encoder.decode([y_pred[i]])[0]}\n")
if len(fn):
    print ("=== False negatives ===")
    for i in fn[:num_samples]:
        print (f"  {X_test_raw[i]}")
        print (f"    true: {label_encoder.decode([y_test[i]])[0]}")
        print (f"    pred: {label_encoder.decode([y_pred[i]])[0]}\n")
```
<pre class="output">
class = 'transformers'

{
  "precision": 0.6428571428571429,
  "recall": 0.6428571428571429,
  "f1": 0.6428571428571429,
  "num_samples": 28.0
}

=== True positives ===
  simple transformers transformers classification ner qa language modeling language generation t5 multi modal conversational ai
    true: ['language-modeling', 'natural-language-processing', 'question-answering', 'transformers']
    pred: ['attention', 'huggingface', 'language-modeling', 'natural-language-processing', 'transformers']

  bertviz tool visualizing attention transformer model bert gpt 2 albert xlnet roberta ctrl etc
    true: ['attention', 'interpretability', 'natural-language-processing', 'transformers']
    pred: ['attention', 'natural-language-processing', 'transformers']

  summary transformers models high level summary differences model huggingfacetransformer library
    true: ['huggingface', 'natural-language-processing', 'transformers']
    pred: ['huggingface', 'natural-language-processing', 'transformers']

=== False positives ===
  help read text summarization using flask huggingface text summarization translation questions answers generation using huggingface deployed using flask streamlit detailed guide github
    true: ['huggingface', 'natural-language-processing']
    pred: ['huggingface', 'natural-language-processing', 'transformers']

  silero models pre trained enterprise grade stt models silero speech text models provide enterprise grade stt compact form factor several commonly spoken languages
    true: ['pytorch', 'tensorflow']
    pred: ['natural-language-processing', 'transformers']

  evaluation metrics language modeling article focus traditional intrinsic metrics extremely useful process training language model
    true: ['language-modeling', 'natural-language-processing']
    pred: ['language-modeling', 'natural-language-processing', 'transformers']

=== False negatives ===
  t5 fine tuning colab notebook showcase fine tune t5 model various nlp tasks especially non text 2 text tasks text 2 text approach
    true: ['natural-language-processing', 'transformers']
    pred: ['natural-language-processing']

  universal adversarial triggers attacking analyzing nlp create short phrases cause specific model prediction concatenated input dataset
    true: ['natural-language-processing', 'transformers']
    pred: ['natural-language-processing']

  tempering expectations gpt 3 openai api closer look magic behind gpt 3 caveats aware
    true: ['natural-language-processing', 'transformers']
    pred: []

</pre>

!!! tip
    While this view is great for cursory inspection, we should have a scaled version that's tied to labeling and boosting workflows so we can act on our findings from this view.

## Confidence learning

While the confusion-matrix sample analysis was a coarse-grained process, we can also use fine-grained confidence based approaches to identify potentially mislabeled samples. Here we’re going to focus on the specific probabilities as opposed to the final model predictions.

Simple confidence based techniques include identifying samples whose:

- **Categorical**
    - prediction is incorrect (also indicate TN, FP, FN)
    - confidence score for the correct class is below a threshold
    - confidence score for an incorrect class is above a threshold
    - standard deviation of confidence scores over top N samples is low
    - different predictions from same model using different/previous parameters
- **Continuous**
    - difference between predicted and ground-truth values is above some %

```python linenums="1"
# Confidence score for the incorrect class is above a threshold
high_confidence = []
max_threshold = 0.2
for i in range(len(y_test)):
    indices = np.where(y_test[i]==0)[0]
    probs = y_prob[i][indices]
    classes = []
    for index in np.where(probs>=max_threshold)[0]:
        classes.append(label_encoder.index_to_class[indices[index]])
    if len(classes):
        high_confidence.append({"text": test_df.text[i], "classes": classes})
```

```python linenums="1"
high_confidence[0:5]
```

<pre class="output">
[{'classes': ['computer-vision', 'scikit-learn'],
  'text': 'mljar supervised automated machine learning python package designed save time data scientist'},
 {'classes': ['computer-vision', 'pytorch'],
  'text': 'bootstrap latent approach self supervised learning new approach self supervised image representation learning'},
 {'classes': ['attention', 'huggingface'],
  'text': 'simple transformers transformers classification ner qa language modeling language generation t5 multi modal conversational ai'},
 {'classes': ['embeddings'],
  'text': 'entity embedding lstm time series demonstration using lstm forecasting structured time series data containing categorical numerical features'},
 {'classes': ['huggingface'],
  'text': 'bertviz tool visualizing attention transformer model bert gpt 2 albert xlnet roberta ctrl etc'}]
</pre>

## Calibration

But these are fairly crude techniques because neural networks are easily overconfident and so their confidences cannot be used without [calibrating](https://arxiv.org/abs/1706.04599){:target="_blank"} them.

<div class="ai-center-all">
    <img src="https://raw.githubusercontent.com/GokuMohandas/MadeWithML/main/images/mlops/evaluation/calibration.png" width="400" alt="accuracy vs. confidence">
</div>
<div class="ai-center-all mt-1">
  <small>Modern (large) neural networks result in higher accuracies but are over confident.<br><a href="https://arxiv.org/abs/1706.04599" target="_blank">On Calibration of Modern Neural Networks</a></small>
</div>

* **Assumption**: *“the probability associated with the predicted class label should reflect its ground truth correctness likelihood.”*
* **Reality**: *“modern (large) neural networks are no longer well-calibrated”*
* **Solution**: apply temperature scaling (extension of [Platt scaling](https://en.wikipedia.org/wiki/Platt_scaling){:target="_blank"}) on model outputs

Recent work on [confident learning](https://arxiv.org/abs/1911.00068){:target="_blank"} ([cleanlab](https://github.com/cleanlab/cleanlab){:target="_blank"}) focuses on identifying noisy labels (with calibration), which can then be properly relabeled and used for training.

```python linenums="1"
import cleanlab
from cleanlab.util import onehot2int
from cleanlab.pruning import get_noise_indices
```

```python linenums="1"
# Format our noisy labels `s` (cleanlab expects list of integers for multilabel tasks)
correctly_formatted_labels = onehot2int(y_test)
```

```python linenums="1"
# Determine potential labeling errors
label_error_indices = get_noise_indices(
            s=correctly_formatted_labels,
            psx=y_prob,
            multi_label=True,
            sorted_index_method="self_confidence",
            verbose=0)
```

Not all of these are necessarily labeling errors but situations where the predicted probabilities were not so confident. Therefore, it will be useful to attach the predicted outcomes along side results. This way, we can know if we need to relabel, upsample, etc. as mitigation strategies to improve our performance.

```python linenums="1"
num_samples = 5
for index in label_error_indices[:num_samples]:
    print ("text:", test_df.iloc[index].text)
    print ("labels:",test_df.iloc[index].tags)
    print ("pred:", label_encoder.decode([y_pred[index]]))
    print ()
```

<pre class="output">
text: simclr keras tensorflow keras implementation simclr
labels: ['keras', 'self-supervised-learning', 'tensorflow']
pred: [['keras', 'tensorflow']]

text: tensorflow js object detection browser real time object detection model browser using tensorflow js
labels: ['computer-vision', 'object-detection', 'tensorflow', 'tensorflow-js']
pred: [['computer-vision', 'convolutional-neural-networks', 'keras', 'object-detection', 'tensorflow', 'tensorflow-js']]

text: pokezoo deep learning based web app developed using mern stack tensorflow js
labels: ['computer-vision', 'image-classification', 'tensorflow', 'tensorflow-js']
pred: [['computer-vision', 'keras', 'tensorflow', 'tensorflow-js']]

text: pcdet 3d point cloud detection pcdet toolbox pytorch 3d object detection point cloud
labels: ['computer-vision', 'convolutional-neural-networks', 'object-detection', 'pytorch']
pred: [['computer-vision', 'object-detection', 'pytorch']]

text: clustered graph convolutional networks pytorch implementation cluster gcn efficient algorithm training deep large graph convolutional networks kdd 2019
labels: ['embeddings', 'graphs', 'node-classification', 'pytorch', 'representation-learning']
pred: [['embeddings', 'graph-neural-networks', 'graphs', 'node-classification', 'pytorch', 'representation-learning']]
</pre>

## Manual slices

Just inspecting the overall and class metrics isn't enough to deploy our new version to production. There may be key slices of our dataset that we need to do really well on:

- Target / predicted classes (+ combinations)
- Features (explicit and implicit)
- Metadata (timestamps, sources, etc.)
- Priority slices / experience (minority groups, large customers, etc.)

An easy way to create and evaluate slices is to define slicing functions.

```python linenums="1"
from snorkel.slicing import PandasSFApplier
from snorkel.slicing import slice_dataframe
from snorkel.slicing import slicing_function
```

```python linenums="1"
@slicing_function()
def cv_transformers(x):
    """Projects with the `computer-vision` and `transformers` tags."""
    return all(tag in x.tags for tag in ["computer-vision", "transformers"])
```

```python linenums="1"
@slicing_function()
def short_text(x):
    """Projects with short titles and descriptions."""
    return len(x.text.split()) < 7  # less than 7 words
```

Here we're using Snorkel's [`slicing_function`](https://snorkel.readthedocs.io/en/v0.9.3/packages/_autosummary/slicing/snorkel.slicing.slicing_function.html){:target="blank"} to create our different slices. We can visualize our slices by applying this slicing function to a relevant DataFrame using [`slice_dataframe`](https://snorkel.readthedocs.io/en/v0.9.3/packages/_autosummary/slicing/snorkel.slicing.slice_dataframe.html){:target="_blank"}.

```python linenums="1"
short_text_df = slice_dataframe(test_df, short_text)
short_text_df[["text", "tags"]].head()
```

<div class="output_subarea output_html rendered_html"><div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>text</th>
      <th>tags</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>44</th>
      <td>flask sqlalchemy adds sqlalchemy support flask	</td>
      <td>[flask]</td>
    </tr>
    <tr>
      <th>69</th>
      <td>scikit lego extra blocks sklearn pipelines	</td>
      <td>[scikit-learn]</td>
    </tr>
    <tr>
      <th>83</th>
      <td>simclr keras tensorflow keras implementation s...</td>
      <td>[keras, self-supervised-learning, tensorflow]</td>
    </tr>
    <tr>
      <th>215</th>
      <td>introduction autoencoders look autoencoders re...	</td>
      <td>[autoencoders, representation-learning]</td>
    </tr>
  </tbody>
</table>
</div></div>

We can define even more slicing functions and create a slices record array using the [`PandasSFApplier`](https://snorkel.readthedocs.io/en/v0.9.6/packages/_autosummary/slicing/snorkel.slicing.PandasSFApplier.html){:target="_blank"}. The slices array has N (# of data points) items and each item has S (# of slicing functions) items, indicating whether that data point is part of that slice. Think of this record array as a masking layer for each slicing function on our data.

```python linenums="1"
# Slices
slicing_functions = [cv_transformers, short_text]
applier = PandasSFApplier(slicing_functions)
slices = applier.apply(test_df)
print (slices)
```

<pre class="output">
rec.array([(0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0),
           (1, 0) (0, 0) (0, 1) (0, 0) (0, 0) (1, 0) (0, 0) (0, 0) (0, 1) (0, 0)
           ...
           (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 1),
           (0, 0), (0, 0)],
    dtype=[('cv_transformers', 'i8'), ('short_text', 'i8')])
</pre>

If our task was multiclass instead of multilabel, we could've used [snorkel.analysis.Scorer](https://snorkel.readthedocs.io/en/v0.9.1/packages/_autosummary/analysis/snorkel.analysis.Scorer.html){:target="_blank"} to retrieve our slice metrics. But we've implemented a naive version for our multilabel task based on it.

```python linenums="1"
# Score slices
metrics["slices"] = {}
for slice_name in slices.dtype.names:
    mask = slices[slice_name].astype(bool)
    if sum(mask):
        slice_metrics = precision_recall_fscore_support(
            y_test[mask], y_pred[mask], average="micro"
        )
        metrics["slices"][slice_name] = {}
        metrics["slices"][slice_name]["precision"] = slice_metrics[0]
        metrics["slices"][slice_name]["recall"] = slice_metrics[1]
        metrics["slices"][slice_name]["f1"] = slice_metrics[2]
        metrics["slices"][slice_name]["num_samples"] = len(y_true[mask])
```

```python linenums="1"
print(json.dumps(metrics["slices"], indent=2))
```

<pre class="output">
{
  "pytorch_transformers": {
    "precision": 0.9230769230769231,
    "recall": 0.8571428571428571,
    "f1": 0.888888888888889,
    "num_samples": 3
  },
  "short_text": {
    "precision": 0.8,
    "recall": 0.5714285714285714,
    "f1": 0.6666666666666666,
    "num_samples": 4
  }
}
</pre>

## Generated slices

Manually creating slices is a massive improvement towards identifying problem subsets in our dataset compared to coarse-grained evaluation but what if there are problematic slices of our dataset that we failed to identify? [SliceLine](https://mboehm7.github.io/resources/sigmod2021b_sliceline.pdf){:target="_blank"} is a recent work that uses a linear-algebra and pruning based technique to identify large slices (specify minimum slice size) that result in meaningful errors from the forward pass. Without pruning, automatic slice identification becomes computationally intensive because it involves enumerating through many combinations of data points to identify the slices. But with this technique, we can discover hidden underperforming subsets in our dataset that we weren’t explicitly looking for!

<div class="ai-center-all">
    <img src="https://raw.githubusercontent.com/GokuMohandas/MadeWithML/main/images/mlops/evaluation/slicefinder.png" width="400" alt="slicefinder GUI">
</div>
<div class="ai-center-all mt-1">
  <small>SliceFinder GUI<br><a href="https://arxiv.org/abs/1807.06068" target="_blank">Automated Data Slicing for Model Validation</a></small>
</div>

### Hidden stratification

What if the features to generate slices on are implicit/hidden?

<div class="ai-center-all">
    <img src="https://raw.githubusercontent.com/GokuMohandas/MadeWithML/main/images/mlops/evaluation/subgroups.png" width="400" alt="Subgroup examples">
</div>
<div class="ai-center-all mt-1">
  <small><a href="https://arxiv.org/abs/1911.08731" target="_blank">Distributionally Robust Neural Networks for Group Shifts</a></small>
</div>

To address this, there are recent [clustering-based techniques](https://arxiv.org/abs/2011.12945){:target="_blank"} to identify these hidden slices and improve the system.

1. Estimate implicit subclass labels via unsupervised clustering
2. Train new more robust model using these clusters

<div class="ai-center-all">
    <img src="https://raw.githubusercontent.com/GokuMohandas/MadeWithML/main/images/mlops/evaluation/clustering.png" width="400" alt="Identifying subgroups via clustering and training on them.">
</div>
<div class="ai-center-all mt-1">
  <small><a href="https://arxiv.org/abs/2011.12945" target="_blank">No Subclass Left Behind: Fine-Grained Robustness in Coarse-Grained Classification Problems</a></small>
</div>

### Model patching

Another recent work on [model patching](https://arxiv.org/abs/2008.06775){:target="_blank"} takes this another step further by learning how to transform between subgroups so we can train models on the augmented data:

1. Learn transformations (ex. CycleGAN) needed to go from one subgroup to another under the same superclass (label)
2. Learn model on augmented data with artificially introduced subgroup features

<div class="ai-center-all">
    <img src="https://raw.githubusercontent.com/GokuMohandas/MadeWithML/main/images/mlops/evaluation/model_patching.png" width="400" alt="Using learned subgroup transformations to augment data.">
</div>
<div class="ai-center-all mt-1">
  <small><a href="https://arxiv.org//2008.06775" target="_blank">Model Patching: Closing the Subgroup Performance Gap with Data Augmentation</a></small>
</div>

## Evaluating evaluations

We want to ensure that our key metrics on the overall dataset improves with each iteration of our model. Overall metrics include accuracy, precision, recall, f1, etc. and we should define what counts as a performance regression. For example, is a higher precision at the expensive of recall an improvement or a regression? Usually, a team of developers and domain experts will establish what the key metric(s) are while also specifying the lowest regression tolerance for other metrics.

```python linenums="1"
assert precision > prev_precision  # most important, cannot regress
assert recall >= best_prev_recall - 0.03  # recall cannot regress > 3%
assert metrics["class"]["data_augmentation"]["f1"] > prev_data_augmentation_f1  # priority class
assert metrics["slices"]["class"]["cv_transformers"]["f1"] > prev_cv_transformers_f1  # priority slice
```

!!! question "Seems straightforward, doesn't it?"
    With all these different evaluation methods, how can we choose "the best" version of our model if some versions are better for some evaluation criteria?

    ??? quote "Show answer"
        You and your team need to agree on what evaluation criteria are most important and what is the minimum performance required for each one. This will allow us to filter amongst all the different solutions by removing ones that don't satisfy al the minimum requirements and ranking amongst the remaining by which ones perform the best for the highest priority criteria.

> In our [testing lesson](https://madewithml.com/courses/mlops/testing/){:target="_blank"}, we'll cover another way to evaluate our model known as [behavioral testing](https://madewithml.com/courses/mlops/testing/#behavioral-testing){:target="_blank"}, which we'll also include as part of performance report.

## Model CI

An effective way to evaluate our systems is to encapsulate them as a collection (suite) and use them for [continuous integration](cicd.md){:target="_blank"}. We would continue to add to our evaluation suites and they would be executed whenever we are experimenting with changes to our system (new models, data, etc.). Often, problematic slices of data identified during [monitoring](monitoring.md){:target="blank"} are often added to the evaluation test suite to avoid repeating the same regressions in the future.


## Resources

- [Slice-based Learning: A Programming Model for Residual Learning in Critical Data Slices](https://papers.nips.cc/paper/2019/file/351869bde8b9d6ad1e3090bd173f600d-Paper.pdf){:target="_blank"}
- [Robustness Gym: Unifying the NLP Evaluation Landscape](https://arxiv.org/abs/2101.04840){:target="_blank"}


<!-- Citation -->
{% include "cite.md" %}